import { sendMessage, sendTypingIndicator, sendQuickReply, createQuickReply } from '../facebook-api'
import { UnifiedUserStateManager } from './unified-user-state-manager'
import { UserState, UserType, UserContext } from '../../types'
import { CONFIG } from '../config'
import { logger, logUserAction, logBotEvent, logError } from '../logger'
import { errorHandler, createUserError, ErrorType } from '../error-handler'
import { getUserByFacebookId } from '../user-service'
import { getBotSession, getBotStatus } from '../bot-service'
import { supabaseAdmin } from '../supabase'
import { WelcomeType, sendReturningUserMessage } from '../welcome-service'
import { messageProcessor } from './message-processor'
import { FlowManager } from './flow-manager'
import { FlowInitializer } from './flow-initializer'
import { SessionManager } from './session-manager'
import { AdminTakeoverService } from '../admin-takeover-service'
import { UtilityHandlers } from '../handlers/utility-handlers'
import { MarketplaceHandlers } from '../handlers/marketplace-handlers'
import { calculateUserLevel, getLevelSuggestions } from '../utils'

/**
 * Unified Bot System - Main entry point for bot message processing
 * Handles all incoming messages with proper routing and flow management
 */
export class UnifiedBotSystem {
    private static initialized = false

    /**
     * Check if bot is stopped globally
     */
    private static async checkBotStatus(): Promise<boolean> {
        const botStatus = await getBotStatus()
        return botStatus !== 'stopped'
    }

    /**
     * Check if admin is active for the user
     */
    private static async checkAdminActive(user: any): Promise<boolean> {
        const isAdminActive = await AdminTakeoverService.isAdminActive(user.facebook_id)
        return !isAdminActive
    }

    /**
     * Handle special postbacks
     */
    private static async handleSpecialPostbacks(user: any, postback: string): Promise<boolean> {
        switch (postback) {
            case 'USE_BOT':
                await UnifiedUserStateManager.handleUseBot(user.facebook_id)
                return true
            case 'CHAT_ADMIN':
                await UnifiedUserStateManager.handleChatWithAdmin(user.facebook_id)
                return true
            case 'STOP_BOT':
                await UnifiedUserStateManager.handleStopBot(user.facebook_id)
                return true
            case 'BACK_TO_MAIN':
                await UnifiedUserStateManager.handleBackToMain(user.facebook_id)
                return true
        }
        return false
    }

    /**
     * Route based on active session
     */
    private static async routeBasedOnSession(user: any, text: string, isPostback?: boolean, postback?: string): Promise<boolean> {
        const activeSession = await SessionManager.getSession(user.facebook_id)
        if (activeSession) {
            logger.info('User has active session, routing to FlowManager', {
                facebook_id: user.facebook_id,
                flow: activeSession.current_flow
            })
            await this.handleBotUserMessage(user, text, isPostback, postback)
            return true
        }
        return false
    }

    /**
     * Handle based on user state
     */
    private static async handleBasedOnState(user: any, text: string, isPostback?: boolean, postback?: string): Promise<void> {
        const currentState = await UnifiedUserStateManager.getUserState(user.facebook_id)
        if (!currentState) {
            await UnifiedUserStateManager.handleNewUser(user.facebook_id)
            return
        }

        // Check if user is returning within 24 hours
        const userData = await getUserByFacebookId(user.facebook_id)
        if (userData?.welcome_sent && userData?.last_welcome_sent) {
            const lastWelcomeTime = new Date(userData.last_welcome_sent)
            const now = new Date()
            const hoursDiff = (now.getTime() - lastWelcomeTime.getTime()) / (1000 * 60 * 60)
            if (hoursDiff < 24) {
                await sendReturningUserMessage(user.facebook_id)
                return
            }
        }

        // Handle based on current mode
        if (currentState.current_mode === UserState.CHATTING_ADMIN) {
            logger.info('User is chatting with admin, ignoring bot message', { facebook_id: user.facebook_id })
            return
        }

        if (currentState.current_mode === UserState.USING_BOT) {
            await this.handleBotUserMessage(user, text, isPostback, postback)
            return
        }

        if (currentState.current_mode === UserState.CHOOSING) {
            if (isPostback && postback) {
                await FlowManager.handlePostback(user, postback)
            } else {
                await this.handleDefaultMessage(user)
            }
            return
        }

        // Fallback
        await UnifiedUserStateManager.sendChoosingMenu(user.facebook_id)
    }

    /**
     * Log and handle errors
     */
    private static async logAndError(user: any, text: string, isPostback?: boolean, postback?: string, error?: any): Promise<void> {
        const duration = Date.now() - (this as any).startTime || 0
        const messageError = createUserError(
            `Message processing failed: ${error instanceof Error ? error.message : String(error)}`,
            ErrorType.USER_ERROR,
            {
                facebook_id: user.facebook_id,
                text,
                isPostback,
                postback,
                duration
            },
            user.facebook_id
        )
        logError(messageError, { operation: 'message_processing', user, text, isPostback, postback })
        await this.sendErrorMessage(user.facebook_id)
    }

    /**
     * Initialize the bot system (call once at startup)
     */
    static initialize(): void {
        if (this.initialized) {
            console.log('‚ö†Ô∏è Bot system already initialized')
            return
        }

        console.log('üöÄ Initializing Unified Bot System...')
        FlowInitializer.initialize()
        this.initialized = true
        console.log('‚úÖ Unified Bot System initialized successfully')
    }

    /**
     * Main entry point for processing all incoming messages
     * S·ª≠ d·ª•ng UserStateManager th·ªëng nh·∫•t ƒë·ªÉ tr√°nh xung ƒë·ªôt logic
     */
    static async handleMessage(user: any, text: string, isPostback?: boolean, postback?: string): Promise<void> {
        const startTime = Date.now()

        try {
            logger.info('Processing message', {
                facebook_id: user.facebook_id,
                text: text,
                isPostback: isPostback,
                postback: postback
            })

            // Step 1: Check bot status
            const botStatus = await getBotStatus()
            if (botStatus === 'stopped') {
                logger.info('Bot is stopped, ignoring message', { facebook_id: user.facebook_id })
                return
            }

            // Step 2: Check if admin is active for this user
            const isAdminActive = await AdminTakeoverService.isAdminActive(user.facebook_id)
            if (isAdminActive) {
                logger.info('Admin is active for user, ignoring bot message', { facebook_id: user.facebook_id })
                return
            }

            // Step 3: X·ª≠ l√Ω postback ƒë·∫∑c bi·ªát tr∆∞·ªõc (cho user ƒëang ch·ªçn mode)
            if (isPostback && postback) {
                switch (postback) {
                    case 'USE_BOT':
                        await UnifiedUserStateManager.handleUseBot(user.facebook_id)
                        return
                    case 'CHAT_ADMIN':
                        await UnifiedUserStateManager.handleChatWithAdmin(user.facebook_id)
                        return
                    case 'STOP_BOT':
                        await UnifiedUserStateManager.handleStopBot(user.facebook_id)
                        return
                    case 'BACK_TO_MAIN':
                        await UnifiedUserStateManager.handleBackToMain(user.facebook_id)
                        return
                }

                // Route all other postbacks (e.g., REGISTER) directly to FlowManager
                // to avoid welcome/choosing logic interfering before a flow starts
                await FlowManager.handlePostback(user, postback)
                return
            }

            // Step 4: SIMPLIFIED ROUTING - Check session first, then state
            const activeSession = await SessionManager.getSession(user.facebook_id)

            if (activeSession) {
                // User has active session - let FlowManager handle it
                logger.info('User has active session, routing to FlowManager', {
                    facebook_id: user.facebook_id,
                    flow: activeSession.current_flow
                })
                await this.handleBotUserMessage(user, text, isPostback, postback)
                return
            }

            // No active session - check user state
            const currentState = await UnifiedUserStateManager.getUserState(user.facebook_id)

            if (!currentState) {
                // User m·ªõi - x·ª≠ l√Ω welcome v√† chuy·ªÉn sang choosing mode
                await UnifiedUserStateManager.handleNewUser(user.facebook_id)
                return
            }

            // Check if user is returning within 24 hours
            const userData = await getUserByFacebookId(user.facebook_id)
            if (userData?.welcome_sent && userData?.last_welcome_sent) {
                const lastWelcomeTime = new Date(userData.last_welcome_sent)
                const now = new Date()
                const hoursDiff = (now.getTime() - lastWelcomeTime.getTime()) / (1000 * 60 * 60)

                if (hoursDiff < 24) {
                    // User is returning within 24 hours - send returning message
                    await sendReturningUserMessage(user.facebook_id)
                    return
                }
            }

            // Handle based on current state
            if (currentState.current_mode === UserState.CHATTING_ADMIN) {
                logger.info('User is chatting with admin, ignoring bot message', { facebook_id: user.facebook_id })
                return
            }

            if (currentState.current_mode === UserState.USING_BOT) {
                await this.handleBotUserMessage(user, text, isPostback, postback)
                return
            }

            if (currentState.current_mode === UserState.CHOOSING) {
                if (isPostback && postback) {
                    await FlowManager.handlePostback(user, postback)
                } else {
                    // For text messages in CHOOSING state, don't call FlowManager
                    // Let UserStateManager handle it
                    await this.handleDefaultMessage(user)
                }
                return
            }

            // Fallback - send choosing menu
            await UnifiedUserStateManager.sendChoosingMenu(user.facebook_id)

            const duration = Date.now() - startTime
            logBotEvent('message_processed', {
                facebook_id: user.facebook_id,
                duration,
                isPostback: !!isPostback
            })

        } catch (error) {
            const duration = Date.now() - startTime
            const messageError = createUserError(
                `Message processing failed: ${error instanceof Error ? error.message : String(error)}`,
                ErrorType.USER_ERROR,
                {
                    facebook_id: user.facebook_id,
                    text,
                    isPostback,
                    postback,
                    duration
                },
                user.facebook_id
            )

            logError(messageError, { operation: 'message_processing', user, text, isPostback, postback })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * X·ª≠ l√Ω tin nh·∫Øn c·ªßa user ƒëang d√πng bot
     */
    private static async handleBotUserMessage(user: any, text: string, isPostback?: boolean, postback?: string): Promise<void> {
        try {
            // X·ª≠ l√Ω postback
            if (isPostback && postback) {
                await this.handleBotPostback(user, postback)
                return
            }

            // X·ª≠ l√Ω text message
            if (text) {
                // QUAN TR·ªåNG: Ki·ªÉm tra admin takeover TR∆Ø·ªöC khi x·ª≠ l√Ω flow
                // S·ª≠ d·ª•ng simplified anti-spam service
                const { AntiSpamService } = await import('../anti-spam-service')
                const spamResult = await AntiSpamService.checkMessage(user, text)

                if (spamResult.blocked) {
                    logger.info('Message blocked by anti-spam', { facebookId: user.facebook_id, reason: spamResult.reason })

                    // N·∫øu admin ƒëang active - th√¥ng b√°o user
                    if (spamResult.reason === 'admin_active' && spamResult.message) {
                        const { sendMessage } = await import('../facebook-api')
                        await sendMessage(user.facebook_id, spamResult.message)
                    }

                    return
                }

                // Kh√¥ng c√≥ spam - x·ª≠ l√Ω b√¨nh th∆∞·ªùng
                // Th·ª≠ x·ª≠ l√Ω b·∫±ng handlers tr∆∞·ªõc
                const handledByUtility = await UtilityHandlers.handleSpecialKeywords(user, text)
                if (!handledByUtility) {
                    const handledByMarketplace = await MarketplaceHandlers.handleMarketplaceKeywords(user, text)
                    if (!handledByMarketplace) {
                        // Kh√¥ng handler n√†o x·ª≠ l√Ω ƒë∆∞·ª£c, d√πng FlowManager
                        await FlowManager.handleMessage(user, text)
                    }
                }
            } else {
                // No text message - send default message based on user type
                await this.handleDefaultMessage(user)
            }
        } catch (error) {
            logError(error as Error, { operation: 'handle_bot_user_message', user, text, postback })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * X·ª≠ l√Ω postback cho user ƒëang d√πng bot
     */
    private static async handleBotPostback(user: any, postback: string): Promise<void> {
        try {
            // C√°c postback ƒë·∫∑c bi·ªát ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü handleMessage r·ªìi
            // C√°c postback kh√°c x·ª≠ l√Ω b·∫±ng FlowManager
            await FlowManager.handlePostback(user, postback)
        } catch (error) {
            logError(error as Error, { operation: 'handle_bot_postback', user, postback })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * Handle default message when no flow is triggered
     */
    static async handleDefaultMessage(user: any): Promise<void> {
        try {
            // Analyze user context
            const context = await this.analyzeUserContext(user)

            switch (context.userType) {
                case UserType.NEW_USER:
                    await this.handleNewUser(user)
                    break
                case UserType.PENDING_USER:
                    await this.handlePendingUser(user)
                    break
                case UserType.REGISTERED_USER:
                    await this.handleRegisteredUser(user)
                    break
                case UserType.TRIAL_USER:
                    await this.handleTrialUser(user)
                    break
                case UserType.EXPIRED_USER:
                    await this.handleExpiredUser(user)
                    break
                default:
                    await this.handleUnknownUser(user)
            }

        } catch (error) {
            logError(error as Error, { operation: 'handle_default_message', user })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * Analyze user context
     */
    private static async analyzeUserContext(user: any): Promise<UserContext> {
        try {
            return await UnifiedUserStateManager.analyzeUserContext(user.facebook_id)
        } catch (error) {
            logError(error as Error, { operation: 'analyze_user_context', user })
            return {
                userType: UserType.NEW_USER,
                userState: UserState.IDLE,
                user: user,
                session: null,
                isInFlow: false
            }
        }
    }

    /**
     * Handle new user - delegate to UserStateManager to send welcome once
     */
    private static async handleNewUser(user: any): Promise<void> {
        try {
            // Send welcome via WelcomeService (through UnifiedUserStateManager)
            await UnifiedUserStateManager.handleNewUser(user.facebook_id)
        } catch (error) {
            logger.error('Error handling new user in UnifiedBotSystem', { facebookId: user.facebook_id, error })
        }
    }

    /**
     * Handle pending user
     */
    private static async handlePendingUser(user: any): Promise<void> {
        try {
            await sendMessage(user.facebook_id,
                `‚è≥ T√ÄI KHO·∫¢N ƒêANG CH·ªú DUY·ªÜT\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìã ƒê∆°n ƒëƒÉng k√Ω c·ªßa b·∫°n ƒëang ƒë∆∞·ª£c xem x√©t\n‚è∞ Th·ªùi gian duy·ªát: 1-2 ng√†y l√†m vi·ªác\nüìû Li√™n h·ªá admin n·∫øu c·∫ßn h·ªó tr·ª£\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

            await sendQuickReply(user.facebook_id, 'T√πy ch·ªçn:', [
                createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                createQuickReply('üîç T√åM KI·∫æM S·∫¢N PH·∫®M', 'SEARCH'),
                createQuickReply('‚ÑπÔ∏è TH√îNG TIN', 'INFO')
            ])

        } catch (error) {
            logError(error as Error, { operation: 'handle_pending_user', user })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * Handle registered user
     */
    private static async handleRegisteredUser(user: any): Promise<void> {
        try {
            // Get user's points and level
            const { data: userPointsData } = await supabaseAdmin
                .from('user_points')
                .select('points')
                .eq('user_id', user.id)
                .single()

            const userPoints = userPointsData?.points || 0
            const userLevel = calculateUserLevel(userPoints)
            const suggestion = getLevelSuggestions(userLevel, userPoints)

            await sendMessage(user.facebook_id,
                `üëã CH√ÄO M·ª™NG TR·ªû L·∫†I!\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng t·∫•t c·∫£ t√≠nh nƒÉng\nüõí ƒêƒÉng tin b√°n h√†ng\nüîç T√¨m ki·∫øm s·∫£n ph·∫©m\nüë• Tham gia c·ªông ƒë·ªìng\n\nüèÜ C·∫•p ƒë·ªô: ${userLevel} (${userPoints} ƒëi·ªÉm)\n${suggestion}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

            await sendQuickReply(user.facebook_id, 'Ch·ªçn t√≠nh nƒÉng:', [
                createQuickReply('üìù ƒêƒÇNG TIN', 'LISTING'),
                createQuickReply('üîç T√åM KI·∫æM', 'SEARCH'),
                createQuickReply('üë• C·ªòNG ƒê·ªíNG', 'COMMUNITY'),
                createQuickReply('üí∞ THANH TO√ÅN', 'PAYMENT'),
                createQuickReply('‚ÑπÔ∏è TH√îNG TIN', 'INFO')
            ])

        } catch (error) {
            logError(error as Error, { operation: 'handle_registered_user', user })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * Handle trial user
     */
    private static async handleTrialUser(user: any): Promise<void> {
        try {
            // Fix: Use membership_expires_at instead of trial_end
            const expiryDate = user.membership_expires_at
            let daysLeft = 0

            if (expiryDate) {
                const trialEnd = new Date(expiryDate)
                const now = new Date()
                const diffTime = trialEnd.getTime() - now.getTime()
                daysLeft = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
                daysLeft = Math.max(daysLeft, 0) // Ensure non-negative
            }

            await sendMessage(user.facebook_id,
                `üéÅ T√ÄI KHO·∫¢N D√ôNG TH·ª¨\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚è∞ C√≤n l·∫°i: ${daysLeft} ng√†y\nüéØ S·ª≠ d·ª•ng FULL t√≠nh nƒÉng mi·ªÖn ph√≠\nüí≥ N√¢ng c·∫•p ƒë·ªÉ ti·∫øp t·ª•c\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

            await sendQuickReply(user.facebook_id, 'Ch·ªçn t√≠nh nƒÉng:', [
                createQuickReply('üìù ƒêƒÇNG TIN', 'LISTING'),
                createQuickReply('üîç T√åM KI·∫æM', 'SEARCH'),
                createQuickReply('üë• C·ªòNG ƒê·ªíNG', 'COMMUNITY'),
                createQuickReply('üí≥ N√ÇNG C·∫§P', 'UPGRADE'),
                createQuickReply('‚ÑπÔ∏è TH√îNG TIN', 'INFO')
            ])

        } catch (error) {
            logError(error as Error, { operation: 'handle_trial_user', user })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * Handle expired user
     */
    private static async handleExpiredUser(user: any): Promise<void> {
        try {
            await sendMessage(user.facebook_id,
                `‚è∞ T√ÄI KHO·∫¢N ƒê√É H·∫æT H·∫†N\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüí≥ Gia h·∫°n ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng\nüéÅ ∆Øu ƒë√£i ƒë·∫∑c bi·ªát cho th√†nh vi√™n c≈©\nüìû Li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

            await sendQuickReply(user.facebook_id, 'T√πy ch·ªçn:', [
                createQuickReply('üí≥ GIA H·∫†N', 'RENEW'),
                createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                createQuickReply('‚ÑπÔ∏è TH√îNG TIN', 'INFO')
            ])

        } catch (error) {
            logError(error as Error, { operation: 'handle_expired_user', user })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * Handle unknown user
     */
    private static async handleUnknownUser(user: any): Promise<void> {
        try {
            await sendMessage(user.facebook_id,
                `‚ùì KH√îNG X√ÅC ƒê·ªäNH ƒê∆Ø·ª¢C TR·∫†NG TH√ÅI\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîÑ Vui l√≤ng th·ª≠ l·∫°i sau\nüìû Li√™n h·ªá admin n·∫øu v·∫•n ƒë·ªÅ ti·∫øp t·ª•c\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

            await sendQuickReply(user.facebook_id, 'T√πy ch·ªçn:', [
                createQuickReply('üîÑ TH·ª¨ L·∫†I', 'RETRY'),
                createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                createQuickReply('‚ÑπÔ∏è TH√îNG TIN', 'INFO')
            ])

        } catch (error) {
            logError(error as Error, { operation: 'handle_unknown_user', user })
            await this.sendErrorMessage(user.facebook_id)
        }
    }

    /**
     * Send error message
     */
    private static async sendErrorMessage(facebookId: string): Promise<void> {
        try {
            await sendMessage(facebookId, '‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau!')
        } catch (error) {
            logError(error as Error, { operation: 'send_error_message', facebookId })
        }
    }

    /**
     * Helper method to add delay between messages
     */
    private static async delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms))
    }

    /**
     * Hi·ªÉn th·ªã l·∫°i c√°c n√∫t c·ªßa b∆∞·ªõc hi·ªán t·∫°i khi user b·ªã spam
     */
    private static async showCurrentStepButtons(user: any): Promise<void> {
        try {
            // L·∫•y session hi·ªán t·∫°i ƒë·ªÉ bi·∫øt user ƒëang ·ªü b∆∞·ªõc n√†o
            const activeSession = await SessionManager.getSession(user.facebook_id)

            if (activeSession) {
                // User ƒëang trong flow - hi·ªÉn th·ªã l·∫°i menu c·ªßa flow ƒë√≥
                const { FlowManager } = await import('./flow-manager')
                const flow = FlowManager.getFlow(activeSession.current_flow)

                if (flow) {
                    // G·ª≠i th√¥ng b√°o user ƒëang ·ªü b∆∞·ªõc n√†o v√† hi·ªÉn th·ªã menu ph√π h·ª£p
                    await this.sendCurrentStepMessage(user, activeSession.current_flow)
                    logger.info('Showed current step buttons for user in flow', {
                        facebookId: user.facebook_id,
                        flow: activeSession.current_flow
                    })
                }
            } else {
                // User kh√¥ng trong flow - hi·ªÉn th·ªã menu ch√≠nh
                await UnifiedUserStateManager.sendBotMenu(user.facebook_id)
                logger.info('Showed main menu buttons for user', { facebookId: user.facebook_id })
            }
        } catch (error) {
            logger.error('Error showing current step buttons', { facebookId: user.facebook_id, error })
        }
    }

    /**
     * G·ª≠i th√¥ng b√°o v·ªÅ b∆∞·ªõc hi·ªán t·∫°i v√† menu ph√π h·ª£p
     */
    private static async sendCurrentStepMessage(user: any, flowName: string): Promise<void> {
        try {
            const { sendMessage, sendQuickReply, createQuickReply } = await import('../facebook-api')

            let stepMessage = ''
            let buttons: any[] = []

            switch (flowName) {
                case 'registration':
                    stepMessage = 'üìù B∆Ø·ªöC ƒêƒÇNG K√ù\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nVui l√≤ng ho√†n th√†nh vi·ªác ƒëƒÉng k√Ω ƒë·ªÉ s·ª≠ d·ª•ng bot:'
                    buttons = [
                        createQuickReply('üìù TI·∫æP T·ª§C ƒêƒÇNG K√ù', 'RESUME_REGISTRATION'),
                        createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                        createQuickReply('üè† V·ªÄ MENU CH√çNH', 'BACK_TO_MAIN')
                    ]
                    break

                case 'listing':
                    stepMessage = 'üõí B∆Ø·ªöC ƒêƒÇNG B√ÅN\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nVui l√≤ng ho√†n th√†nh vi·ªác ƒëƒÉng b√°n:'
                    buttons = [
                        createQuickReply('üìù TI·∫æP T·ª§C ƒêƒÇNG B√ÅN', 'RESUME_LISTING'),
                        createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                        createQuickReply('üè† V·ªÄ MENU CH√çNH', 'BACK_TO_MAIN')
                    ]
                    break

                case 'search':
                    stepMessage = 'üîç B∆Ø·ªöC T√åM KI·∫æM\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nVui l√≤ng ho√†n th√†nh vi·ªác t√¨m ki·∫øm:'
                    buttons = [
                        createQuickReply('üîç TI·∫æP T·ª§C T√åM KI·∫æM', 'RESUME_SEARCH'),
                        createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                        createQuickReply('üè† V·ªÄ MENU CH√çNH', 'BACK_TO_MAIN')
                    ]
                    break

                default:
                    stepMessage = 'üîÑ B∆Ø·ªöC HI·ªÜN T·∫†I\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nVui l√≤ng ho√†n th√†nh thao t√°c hi·ªán t·∫°i:'
                    buttons = [
                        createQuickReply('‚ñ∂Ô∏è TI·∫æP T·ª§C', 'RESUME_CURRENT'),
                        createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                        createQuickReply('üè† V·ªÄ MENU CH√çNH', 'BACK_TO_MAIN')
                    ]
            }

            await sendMessage(user.facebook_id, stepMessage)
            await sendQuickReply(user.facebook_id, 'Ch·ªçn h√†nh ƒë·ªông:', buttons)

        } catch (error) {
            logger.error('Error sending current step message', { facebookId: user.facebook_id, flowName, error })
        }
    }

    /**
     * Hi·ªÉn th·ªã ch·ªâ n√∫t chat admin khi user b·ªã spam qu√° nhi·ªÅu
     */
    private static async showAdminChatButtonOnly(user: any): Promise<void> {
        try {
            const { sendMessage, sendQuickReply, createQuickReply } = await import('../facebook-api')

            await sendMessage(user.facebook_id, 'üö´ B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu tin nh·∫Øn!\nüí¨ Vui l√≤ng chat tr·ª±c ti·∫øp v·ªõi admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.')

            await sendQuickReply(user.facebook_id, 'Li√™n h·ªá admin:', [
                createQuickReply('üí¨ CHAT V·ªöI ADMIN', 'CONTACT_ADMIN'),
                createQuickReply('üè† V·ªÄ MENU CH√çNH', 'BACK_TO_MAIN')
            ])

            logger.info('Showed admin chat button only for user', { facebookId: user.facebook_id })
        } catch (error) {
            logger.error('Error showing admin chat button only', { facebookId: user.facebook_id, error })
        }
    }

    /**
     * G·ª≠i bot menu v·ªõi nhi·ªÅu quick reply
     */
    private static async sendBotMenu(user: any): Promise<void> {
        try {
            const { sendQuickReply, createQuickReply } = await import('../facebook-api')

            await sendQuickReply(user.facebook_id, 'ü§ñ MENU BOT T√ÇN D·∫¨U\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nCh·ªçn ch·ª©c nƒÉng b·∫°n mu·ªën s·ª≠ d·ª•ng:', [
                createQuickReply('üöÄ ƒêƒÇNG K√ù TH√ÄNH VI√äN', 'REGISTER'),
                createQuickReply('üõí ƒêƒÇNG TIN B√ÅN H√ÄNG', 'LISTING'),
                createQuickReply('üîç T√åM KI·∫æM S·∫¢N PH·∫®M', 'SEARCH'),
                createQuickReply('üë• C·ªòNG ƒê·ªíNG T√ÇN D·∫¨U', 'COMMUNITY'),
                createQuickReply('üí∞ THANH TO√ÅN', 'PAYMENT'),
                createQuickReply('üí¨ LI√äN H·ªÜ ADMIN', 'CONTACT_ADMIN'),
                createQuickReply('‚ÑπÔ∏è TH√îNG TIN', 'INFO'),
                createQuickReply('üè† V·ªÄ MENU CH√çNH', 'BACK_TO_MAIN')
            ])

            logger.info('Sent enhanced bot menu', { facebookId: user.facebook_id })
        } catch (error) {
            logger.error('Error sending bot menu', { facebookId: user.facebook_id, error })
        }
    }
}
