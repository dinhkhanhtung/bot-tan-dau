import { supabaseAdmin } from '../supabase'
import { getBotSession } from '../utils'

// User type definitions - Simplified and clear
export enum UserType {
    ADMIN = 'admin',
    REGISTERED_USER = 'registered_user',
    TRIAL_USER = 'trial_user',
    PENDING_USER = 'pending_user', // ‚Üê TH√äM M·ªöI: User ƒëang ch·ªù admin duy·ªát
    NEW_USER = 'new_user',
    EXPIRED_USER = 'expired_user'
}

export enum UserState {
    IDLE = 'idle',
    IN_REGISTRATION = 'in_registration',
    IN_LISTING = 'in_listing',
    IN_SEARCH = 'in_search',
    IN_ADMIN_CHAT = 'in_admin_chat',
    IN_PAYMENT = 'in_payment'
}

export interface UserContext {
    userType: UserType
    userState: UserState
    user: any
    session: any
    isInFlow: boolean
    flowType?: string
}

// Permission Matrix cho t·ª´ng lo·∫°i user
export interface UserPermissions {
    canUseBot: boolean
    canSearch: boolean
    canViewListings: boolean
    canCreateListings: boolean
    canContactSellers: boolean
    canMakePayments: boolean
    canUseAdminChat: boolean
    canAccessCommunity: boolean
    canUsePoints: boolean
    canAccessSettings: boolean
    maxListingsPerDay?: number
    maxSearchesPerDay?: number
    maxMessagesPerDay?: number
}

// Permission definitions cho t·ª´ng user type
export const USER_PERMISSIONS: Record<UserType, UserPermissions> = {
    [UserType.ADMIN]: {
        canUseBot: true,
        canSearch: true,
        canViewListings: true,
        canCreateListings: true,
        canContactSellers: true,
        canMakePayments: true,
        canUseAdminChat: true,
        canAccessCommunity: true,
        canUsePoints: true,
        canAccessSettings: true,
        maxListingsPerDay: 999,
        maxSearchesPerDay: 999,
        maxMessagesPerDay: 999
    },
    [UserType.REGISTERED_USER]: {
        canUseBot: true,
        canSearch: true,
        canViewListings: true,
        canCreateListings: true,
        canContactSellers: true,
        canMakePayments: true,
        canUseAdminChat: true,
        canAccessCommunity: true,
        canUsePoints: true,
        canAccessSettings: true,
        maxListingsPerDay: 10,
        maxSearchesPerDay: 50,
        maxMessagesPerDay: 100
    },
    [UserType.TRIAL_USER]: {
        canUseBot: true,
        canSearch: true,
        canViewListings: true,
        canCreateListings: true,
        canContactSellers: true,
        canMakePayments: true,
        canUseAdminChat: true,
        canAccessCommunity: true,
        canUsePoints: true,
        canAccessSettings: true,
        maxListingsPerDay: 5,
        maxSearchesPerDay: 20,
        maxMessagesPerDay: 50
    },
    [UserType.PENDING_USER]: {
        canUseBot: true,
        canSearch: true,
        canViewListings: true,
        canCreateListings: false, // ‚Üê GI·ªöI H·∫†N: Kh√¥ng ƒë∆∞·ª£c ni√™m y·∫øt
        canContactSellers: false, // ‚Üê GI·ªöI H·∫†N: Kh√¥ng ƒë∆∞·ª£c li√™n h·ªá ng∆∞·ªùi b√°n
        canMakePayments: false,
        canUseAdminChat: true,
        canAccessCommunity: false,
        canUsePoints: false,
        canAccessSettings: false,
        maxListingsPerDay: 0,
        maxSearchesPerDay: 10,
        maxMessagesPerDay: 20
    },
    [UserType.NEW_USER]: {
        canUseBot: false,
        canSearch: false,
        canViewListings: false,
        canCreateListings: false,
        canContactSellers: false,
        canMakePayments: false,
        canUseAdminChat: true,
        canAccessCommunity: false,
        canUsePoints: false,
        canAccessSettings: false,
        maxListingsPerDay: 0,
        maxSearchesPerDay: 0,
        maxMessagesPerDay: 5
    },
    [UserType.EXPIRED_USER]: {
        canUseBot: false,
        canSearch: false,
        canViewListings: false,
        canCreateListings: false,
        canContactSellers: false,
        canMakePayments: true, // ‚Üê Cho ph√©p thanh to√°n ƒë·ªÉ gia h·∫°n
        canUseAdminChat: true,
        canAccessCommunity: false,
        canUsePoints: false,
        canAccessSettings: false,
        maxListingsPerDay: 0,
        maxSearchesPerDay: 0,
        maxMessagesPerDay: 5
    }
}

// Simplified Context Manager - ƒê∆†N GI·∫¢N V√Ä R√ï R√ÄNG
export class SmartContextManager {

    /**
     * Ph√¢n t√≠ch ng·ªØ c·∫£nh ƒê∆†N GI·∫¢N v√† CH√çNH X√ÅC c·ªßa user
     */
    static async analyzeUserContext(user: any): Promise<UserContext> {
        try {
            // B∆Ø·ªöC 1: KI·ªÇM TRA ADMIN TR∆Ø·ªöC (∆∞u ti√™n cao nh·∫•t)
            const isAdminUser = await this.detectAdmin(user.facebook_id)

            if (isAdminUser) {
                return {
                    userType: UserType.ADMIN,
                    userState: UserState.IDLE,
                    user,
                    session: null,
                    isInFlow: false
                }
            }

            // B∆Ø·ªöC 2: L·∫§Y TH√îNG TIN USER T·ª™ DATABASE
            const { data: userData } = await supabaseAdmin
                .from('users')
                .select('*')
                .eq('facebook_id', user.facebook_id)
                .single()

            // B∆Ø·ªöC 3: KI·ªÇM TRA SESSION HI·ªÜN T·∫†I
            const session = await getBotSession(user.facebook_id)

            // B∆Ø·ªöC 4: X√ÅC ƒê·ªäNH LO·∫†I USER - R√ï R√ÄNG
            let userType = UserType.NEW_USER
            let userState = UserState.IDLE

            if (userData) {
                // User ƒë√£ t·ªìn t·∫°i trong database
                if (userData.status === 'registered') {
                    userType = UserType.REGISTERED_USER
                } else if (userData.status === 'trial') {
                    userType = UserType.TRIAL_USER
                } else if (userData.status === 'pending') {
                    userType = UserType.PENDING_USER // ‚Üê TH√äM M·ªöI: X·ª≠ l√Ω pending user
                } else if (userData.status === 'expired') {
                    userType = UserType.EXPIRED_USER
                }

                // KI·ªÇM TRA TR·∫†NG TH√ÅI FLOW - ƒê∆†N GI·∫¢N
                if (session?.current_flow) {
                    switch (session.current_flow) {
                        case 'registration':
                            userState = UserState.IN_REGISTRATION
                            break
                        case 'listing':
                            userState = UserState.IN_LISTING
                            break
                        case 'search':
                            userState = UserState.IN_SEARCH
                            break
                        case 'payment':
                            userState = UserState.IN_PAYMENT
                            break
                        default:
                            userState = UserState.IDLE
                    }
                }
            } else {
                // User m·ªõi ho√†n to√†n - CH·∫ÆC CH·∫ÆN
                userType = UserType.NEW_USER
                userState = UserState.IDLE
            }

            return {
                userType,
                userState,
                user: userData || user,
                session,
                isInFlow: userState !== UserState.IDLE,
                flowType: session?.current_flow
            }

        } catch (error) {
            console.error('Error analyzing user context:', error)
            // Fallback ƒê∆†N GI·∫¢N: coi nh∆∞ new user
            return {
                userType: UserType.NEW_USER,
                userState: UserState.IDLE,
                user,
                session: null,
                isInFlow: false
            }
        }
    }

    /**
     * Ph√°t hi·ªán admin user - DEPRECATED: Now handled by FACEBOOK_PAGE_ID check
     */
    private static async detectAdmin(facebookId: string): Promise<boolean> {
        // New logic: Only fanpage messages are admin
        return facebookId === process.env.FACEBOOK_PAGE_ID
    }

    /**
     * L·∫•y menu ph√π h·ª£p d·ª±a tr√™n ng·ªØ c·∫£nh
     */
    static getContextualMenu(context: UserContext): any[] {
        const { userType, userState, isInFlow } = context

        // N·∫øu ƒëang trong flow, tr·∫£ v·ªÅ menu ph√π h·ª£p v·ªõi flow hi·ªán t·∫°i
        if (isInFlow) {
            return this.getFlowSpecificMenu(userState, context)
        }

        // Menu d·ª±a tr√™n lo·∫°i user
        switch (userType) {
            case UserType.ADMIN:
                return this.getAdminMenu()
            case UserType.REGISTERED_USER:
            case UserType.TRIAL_USER:
                return this.getRegisteredUserMenu(context)
            case UserType.PENDING_USER:
                return this.getPendingUserMenu(context) // ‚Üê TH√äM M·ªöI: Menu cho pending user
            case UserType.EXPIRED_USER:
                return this.getExpiredUserMenu()
            case UserType.NEW_USER:
            default:
                return this.getNewUserMenu()
        }
    }

    /**
     * Menu cho Admin
     */
    private static getAdminMenu(): any[] {
        return [
            { title: 'üí∞ QU·∫¢N L√ù THANH TO√ÅN', action: 'ADMIN_PAYMENTS', priority: 1 },
            { title: 'üë• QU·∫¢N L√ù NG∆Ø·ªúI D√ôNG', action: 'ADMIN_USERS', priority: 2 },
            { title: 'üõí QU·∫¢N L√ù TIN ƒêƒÇNG', action: 'ADMIN_LISTINGS', priority: 3 },
            { title: 'üìä XEM TH·ªêNG K√ä', action: 'ADMIN_STATS', priority: 4 },
            { title: 'üîî QU·∫¢N L√ù TH√îNG B√ÅO', action: 'ADMIN_NOTIFICATIONS', priority: 5 },
            { title: '‚öôÔ∏è C·∫§U H√åNH H·ªÜ TH·ªêNG', action: 'ADMIN_SETTINGS', priority: 6 }
        ]
    }

    /**
     * Menu cho User ƒë√£ ƒëƒÉng k√Ω
     */
    private static getRegisteredUserMenu(context: UserContext): any[] {
        const menu = [
            { title: 'üè† TRANG CH·ª¶', action: 'MAIN_MENU', priority: 1 },
            { title: 'üõí NI√äM Y·∫æT S·∫¢N PH·∫®M', action: 'LISTING', priority: 2 },
            { title: 'üîç T√åM KI·∫æM', action: 'SEARCH', priority: 3 },
            { title: 'üë• C·ªòNG ƒê·ªíNG', action: 'COMMUNITY', priority: 4 },
            { title: 'üí∞ THANH TO√ÅN', action: 'PAYMENT', priority: 5 },
            { title: '‚≠ê ƒêI·ªÇM TH∆Ø·ªûNG', action: 'POINTS', priority: 6 },
            { title: '‚öôÔ∏è C√ÄI ƒê·∫∂T', action: 'SETTINGS', priority: 7 }
        ]

        // Th√™m th√¥ng tin tr·∫°ng th√°i n·∫øu l√† trial user
        if (context.userType === UserType.TRIAL_USER && context.user?.membership_expires_at) {
            const daysLeft = Math.ceil((new Date(context.user.membership_expires_at).getTime() - Date.now()) / (1000 * 60 * 60 * 24))
            if (daysLeft <= 3) {
                menu.unshift({ title: `‚ö†Ô∏è TRIAL H·∫æT H·∫†N: ${daysLeft} NG√ÄY`, action: 'PAYMENT_URGENT', priority: 0 })
            }
        }

        return menu
    }

    /**
     * Menu cho User ƒëang ch·ªù duy·ªát
     */
    private static getPendingUserMenu(context: UserContext): any[] {
        const menu = [
            { title: 'üîç T√åM KI·∫æM S·∫¢N PH·∫®M', action: 'SEARCH', priority: 1 },
            { title: 'üëÄ XEM TIN ƒêƒÇNG', action: 'VIEW_LISTINGS', priority: 2 },
            { title: 'üí¨ LI√äN H·ªÜ ADMIN', action: 'CONTACT_ADMIN', priority: 3 },
            { title: '‚ÑπÔ∏è TH√îNG TIN', action: 'INFO', priority: 4 }
        ]

        // Th√™m th√¥ng b√°o tr·∫°ng th√°i ch·ªù duy·ªát
        const pendingDays = context.user?.created_at ?
            Math.ceil((Date.now() - new Date(context.user.created_at).getTime()) / (1000 * 60 * 60 * 24)) : 0

        if (pendingDays > 0) {
            menu.unshift({
                title: `‚è≥ CH·ªú DUY·ªÜT: ${pendingDays} NG√ÄY`,
                action: 'PENDING_STATUS',
                priority: 0
            })
        }

        return menu
    }

    /**
     * Menu cho User h·∫øt h·∫°n
     */
    private static getExpiredUserMenu(): any[] {
        return [
            { title: 'üí∞ THANH TO√ÅN ƒê·ªÇ TI·∫æP T·ª§C', action: 'PAYMENT', priority: 1 },
            { title: 'üìù ƒêƒÇNG K√ù L·∫†I', action: 'REGISTER', priority: 2 },
            { title: '‚ÑπÔ∏è TH√îNG TIN', action: 'INFO', priority: 3 }
        ]
    }

    /**
     * Menu cho User m·ªõi
     */
    private static getNewUserMenu(): any[] {
        return [
            { title: 'üöÄ ƒêƒÇNG K√ù NGAY', action: 'REGISTER', priority: 1 },
            { title: '‚ÑπÔ∏è T√åM HI·ªÇU TH√äM', action: 'INFO', priority: 2 },
            { title: 'üí¨ H·ªñ TR·ª¢', action: 'SUPPORT', priority: 3 }
        ]
    }

    /**
     * Menu d√†nh ri√™ng cho t·ª´ng flow
     */
    private static getFlowSpecificMenu(userState: UserState, context: UserContext): any[] {
        switch (userState) {
            case UserState.IN_REGISTRATION:
                return [
                    { title: 'üìù TI·∫æP T·ª§C ƒêƒÇNG K√ù', action: 'CONTINUE_REGISTRATION', priority: 1 },
                    { title: '‚ùå H·ª¶Y ƒêƒÇNG K√ù', action: 'CANCEL_REGISTRATION', priority: 2 },
                    { title: 'üè† V·ªÄ TRANG CH·ª¶', action: 'MAIN_MENU', priority: 3 }
                ]
            case UserState.IN_LISTING:
                return [
                    { title: 'üõí TI·∫æP T·ª§C NI√äM Y·∫æT', action: 'CONTINUE_LISTING', priority: 1 },
                    { title: '‚ùå H·ª¶Y NI√äM Y·∫æT', action: 'CANCEL_LISTING', priority: 2 },
                    { title: 'üè† V·ªÄ TRANG CH·ª¶', action: 'MAIN_MENU', priority: 3 }
                ]
            case UserState.IN_SEARCH:
                return [
                    { title: 'üîç TI·∫æP T·ª§C T√åM KI·∫æM', action: 'CONTINUE_SEARCH', priority: 1 },
                    { title: '‚ùå H·ª¶Y T√åM KI·∫æM', action: 'CANCEL_SEARCH', priority: 2 },
                    { title: 'üè† V·ªÄ TRANG CH·ª¶', action: 'MAIN_MENU', priority: 3 }
                ]
            default:
                return this.getNewUserMenu()
        }
    }

    /**
     * L·∫•y welcome message ph√π h·ª£p v·ªõi ng·ªØ c·∫£nh
     */
    static getContextualWelcomeMessage(context: UserContext): string {
        const { userType, userState, user, isInFlow } = context

        if (isInFlow) {
            return this.getFlowWelcomeMessage(userState, context)
        }

        switch (userType) {
            case UserType.ADMIN:
                return 'üîß ADMIN DASHBOARD\nCh√†o m·ª´ng Admin! B·∫°n c√≥ to√†n quy·ªÅn qu·∫£n l√Ω h·ªá th·ªëng.'

            case UserType.REGISTERED_USER:
                const displayName = user?.name || 'b·∫°n'
                return `‚úÖ CH√ÄO M·ª™NG ${displayName.toUpperCase()}!\nB·∫°n ƒë√£ ƒëƒÉng k√Ω th√†nh c√¥ng v√† c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë·∫ßy ƒë·ªß t√≠nh nƒÉng.`

            case UserType.TRIAL_USER:
                const daysLeft = user?.membership_expires_at ?
                    Math.ceil((new Date(user.membership_expires_at).getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : 7
                return `üéÅ CH√ÄO M·ª™NG B·∫†N ƒê·∫æN V·ªöI G√ìI D√ôNG TH·ª¨!\nB·∫°n c√≤n ${daysLeft} ng√†y s·ª≠ d·ª•ng mi·ªÖn ph√≠.\nüí° H√£y kh√°m ph√° c√°c t√≠nh nƒÉng c·ªßa bot!`

            case UserType.PENDING_USER:
                const pendingDays = user?.created_at ?
                    Math.ceil((Date.now() - new Date(user.created_at).getTime()) / (1000 * 60 * 60 * 24)) : 0
                return `‚è≥ CH√ÄO M·ª™NG ${(user?.name || 'b·∫°n').toUpperCase()}!\n\nüìã Tr·∫°ng th√°i: ƒêang ch·ªù Admin duy·ªát (${pendingDays} ng√†y)\nüîç B·∫°n c√≥ th·ªÉ t√¨m ki·∫øm v√† xem s·∫£n ph·∫©m\nüö´ Ch∆∞a th·ªÉ ni√™m y·∫øt ho·∫∑c li√™n h·ªá ng∆∞·ªùi b√°n\n\nüí° Admin s·∫Ω duy·ªát s·ªõm nh·∫•t c√≥ th·ªÉ!`

            case UserType.EXPIRED_USER:
                return '‚è∞ T√ÄI KHO·∫¢N ƒê√É H·∫æT H·∫†N\nƒê·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng, vui l√≤ng thanh to√°n ƒë·ªÉ gia h·∫°n.'

            case UserType.NEW_USER:
            default:
                return 'üéâ CH√ÄO M·ª™NG ƒê·∫æN V·ªöI BOT T√¢n D·∫≠u - H·ªó Tr·ª£ Ch√©o!\nü§ù C·ªông ƒë·ªìng d√†nh ri√™ng cho nh·ªØng ng∆∞·ªùi con T√¢n D·∫≠u.\n\nüí° ƒê·ªÉ b·∫Øt ƒë·∫ßu, b·∫°n c·∫ßn ƒëƒÉng k√Ω th√†nh vi√™n.'
        }
    }

    /**
     * L·∫•y permissions cho user type
     */
    static getUserPermissions(userType: UserType): UserPermissions {
        return USER_PERMISSIONS[userType] || USER_PERMISSIONS[UserType.NEW_USER]
    }

    /**
     * Ki·ªÉm tra permission cho user
     */
    static hasPermission(userType: UserType, permission: keyof UserPermissions): boolean {
        const permissions = this.getUserPermissions(userType)
        return permissions[permission] === true
    }

    /**
     * Ki·ªÉm tra rate limit cho user
     */
    static async checkRateLimit(userType: UserType, action: 'listings' | 'searches' | 'messages', facebookId: string): Promise<boolean> {
        const permissions = this.getUserPermissions(userType)
        const limit = permissions[`max${action.charAt(0).toUpperCase() + action.slice(1)}PerDay` as keyof UserPermissions] as number

        if (!limit || limit >= 999) return true // No limit for admin/unlimited users

        // TODO: Implement rate limiting logic with database tracking
        // For now, return true (no rate limiting implemented yet)
        return true
    }

    /**
     * Welcome message cho t·ª´ng flow
     */
    private static getFlowWelcomeMessage(userState: UserState, context: UserContext): string {
        switch (userState) {
            case UserState.IN_REGISTRATION:
                return 'üìù ƒêANG ƒêƒÇNG K√ù\nB·∫°n ƒëang trong qu√° tr√¨nh ƒëƒÉng k√Ω.\nH√£y ti·∫øp t·ª•c ho·∫∑c h·ªßy n·∫øu mu·ªën d·ª´ng l·∫°i.'

            case UserState.IN_LISTING:
                return 'üõí ƒêANG NI√äM Y·∫æT\nB·∫°n ƒëang t·∫°o tin ƒëƒÉng m·ªõi.\nH√£y ti·∫øp t·ª•c ho·∫∑c h·ªßy n·∫øu mu·ªën d·ª´ng l·∫°i.'

            case UserState.IN_SEARCH:
                return 'üîç ƒêANG T√åM KI·∫æM\nB·∫°n ƒëang trong ch·∫ø ƒë·ªô t√¨m ki·∫øm n√¢ng cao.\nH√£y ti·∫øp t·ª•c ho·∫∑c h·ªßy n·∫øu mu·ªën d·ª´ng l·∫°i.'

            default:
                return 'üëã Ch√†o m·ª´ng b·∫°n quay tr·ªü l·∫°i!'
        }
    }
}
